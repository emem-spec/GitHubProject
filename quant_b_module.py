# -*- coding: utf-8 -*-
"""Quant B Module

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Uj8Ggqgq1FD5SiMUCHpMgcRU6KYuhbMb
"""

import streamlit as st
import yfinance as yf
import pandas as pd
import numpy as np
import plotly.express as px

def run_quant_b():
    st.header("üìä Gestion de Portefeuille Multi-Actifs (Quant B)")
    st.markdown("---")

    # --- 1. Sidebar : Param√®tres ---
    st.sidebar.header("1. Choix des Actifs")

    # Choix des tickers
    default_tickers = "AAPL, MSFT, GOOGL, AMZN"
    tickers_input = st.sidebar.text_input("Entrez les tickers (s√©par√©s par des virgules)", default_tickers)
    tickers = [x.strip().upper() for x in tickers_input.split(',')]

    # Choix de la p√©riode
    period = st.sidebar.selectbox("P√©riode d'analyse", ["3mo", "6mo", "1y", "2y", "5y"], index=2)

    st.sidebar.header("2. Allocation du Portefeuille")
    st.sidebar.write("D√©finissez les poids pour chaque actif :")

    # Cr√©ation dynamique des sliders pour les poids
    weights = []
    for ticker in tickers:
        w = st.sidebar.slider(f"Poids pour {ticker}", 0.0, 1.0, 1.0/len(tickers), 0.05, key=ticker) # Ajout key unique
        weights.append(w)

    # Normalisation des poids
    total_weight = sum(weights)
    if total_weight == 0:
        norm_weights = [1/len(tickers)] * len(tickers)
    else:
        norm_weights = [w / total_weight for w in weights]

    st.sidebar.info(f"Poids normalis√©s : {[round(w, 2) for w in norm_weights]}")

    # --- 2. R√©cup√©ration des Donn√©es ---
    if len(tickers) < 3:
        st.error("‚ö†Ô∏è Le sujet exige au moins 3 actifs pour la diversification.")
    else:
        try:
            with st.spinner("T√©l√©chargement des donn√©es..."):
                df = yf.download(tickers, period=period, auto_adjust=True)
                closes = df['Close'].dropna()

            # --- 3. Calculs Financiers ---
            daily_returns = closes.pct_change().dropna()
            portfolio_return = daily_returns.dot(norm_weights)

            cumulative_returns = (1 + daily_returns).cumprod() * 100
            cumulative_portfolio = (1 + portfolio_return).cumprod() * 100

            chart_data = cumulative_returns.copy()
            chart_data['PORTFOLIO'] = cumulative_portfolio

            # --- 4. Affichage ---
            col1, col2 = st.columns(2)
            with col1:
                st.subheader("üìà Performance Compar√©e")
                fig = px.line(chart_data, title="√âvolution Base 100")
                st.plotly_chart(fig, use_container_width=True)

            with col2:
                st.subheader("üîó Matrice de Corr√©lation")
                corr_matrix = daily_returns.corr()
                fig_corr = px.imshow(corr_matrix, text_auto=True, color_continuous_scale='RdBu_r', zmin=-1, zmax=1)
                st.plotly_chart(fig_corr, use_container_width=True)

            # Stats
            st.markdown("---")
            volatility = portfolio_return.std() * (252 ** 0.5)
            total_ret = cumulative_portfolio.iloc[-1] - 100

            c1, c2, c3 = st.columns(3)
            c1.metric("Rendement Total", f"{total_ret:.2f} %")
            c2.metric("Volatilit√© Annualis√©e", f"{volatility*100:.2f} %")
            c3.metric("Nombre d'actifs", len(tickers))

        except Exception as e:
            st.error(f"Erreur : {e}")